# -*- coding: utf-8 -*-
"""Blockchain ML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11ltPHUglTYeUEnHCb2ZgN4OEJbc0fmV3

A blockchain is a distributed database with a list (that is, chain) of records (that is, blocks) linked and secured by digital fingerprints (that is, cryptho hashes).

In simple words, we have a series of blocks where each block contains specific transaction information like transaction id.

Each block in the blockchain is connected to the next block through a pre-computed hash function.

A blockchain uses the 



*   block timestamp and
*   the hash from the previous block and
*   the block data (e.g. Transaction Data)
to calculate the new hash digest checksum

### Security in Blockchain

Since blockhain contains important information about transaction, it is important to look into the security of such transaction.

Because blockchain uses consensus algorithm to verify transactions, it is impossible for a single unit to pose a threat to the data network. A node (or unit) that begins to act abnormally can easily be identified and expunged from the network.

### Problem Statement

Based on the transactions of the distributed registry of Bitcoin, to identify the moments of abnormal behavior and transactions in the market, from September to December 2018.

### Problem Solution

To detect such anomalies in transactions through different outlier detection algorithm.
"""

from __future__ import absolute_import


from google.cloud import bigquery
from sklearn.ensemble import IsolationForest
import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

"""Since our dataset is hosted on the google cloud platform, we need to have the required credentials in order to be able to fetch data from the platform and run it here.

We therefore use "My Project 45219-41629692d3a0.json" which is the credential used to login into the cloud platform and fetch the data.
"""

os.environ['GOOGLE_APPLICATION_CREDENTIALS']="/content/My Project 45219-41629692d3a0.json"
client = bigquery.Client()

query = """
SELECT DATE((timestamp)) AS date,
        COUNT(number) AS blocks
FROM `bigquery-public-data.crypto_bitcoin.blocks`
GROUP BY date
HAVING date >= '2018-09-01' AND date <= '2018-12-31'
ORDER BY date

"""

query_job = client.query(query)
# Waits for the query to finish
iterator = query_job.result(timeout=30)
rows = list(iterator)
df = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))

df.head()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
plt.style.use('ggplot')
sns.set_context("notebook", font_scale=1.2, rc={"lines.linewidth": 1.5})

g = plt.subplots(figsize=(20,9))
g = sns.lineplot(x='date', y='blocks', data=df, palette='Blues_b')
plt.title('Blocks per day')

"""Based on the data obtained, we can say that at the end of 2018 the volume of transactions went down (moreover, at the end of November it reached an extremely low level):"""

query_2 = """
SELECT
  o.date,
  SUM(o.output_price) AS sum_output_price,
  COUNT(o.block) AS blocks
FROM (
  SELECT
    DATE((block_timestamp)) AS date,
    output.value AS output_price,
    block_number AS block
  FROM
    `bigquery-public-data.crypto_bitcoin.transactions`,
    UNNEST(outputs) AS output ) AS o
GROUP BY
  o.date
HAVING o.date >= '2018-09-01' AND o.date <= '2018-12-31'
ORDER BY o.date, blocks
"""
query_job_2 = client.query(query_2)
# Waits for the query to finish
iterator_2 = query_job_2.result(timeout=30)
rows_2 = list(iterator_2)
df_2 = pd.DataFrame(data=[list(x.values()) for x in rows_2], columns=list(rows_2[0].keys()))

df_2["sum_output_price"]= df_2["sum_output_price"].apply(lambda x: float(x/100000000))

df_2.head()

g_2 = plt.subplots(figsize=(20,9))
g_2 = sns.lineplot(x='date', y='sum_output_price', data=df_2, palette='BuGn_r')
plt.title('Sum of all satoshis spent each day')

"""Now let's look at how the cost per byte in Satoshi has changed over the entire period under consideration. It is clearly seen that the price soared “at the end” of 2018 -
between November and December first week.
"""

sns.set(style="ticks")
sns.pairplot(df_2)

"""We will group the data by the date the blocks were created and look at the ratio “quantity created to value”. We can notice that at some point the cost almost doubled.

We first try to detect such anomaly in the transaction data through outlier detection algorithm like Isolation Forest.

### Outlier Ensembles Based Model

### Isolation Forest
"""

X = df_2.iloc[:,1:3].values
 
ifr = IsolationForest(contamination=0.1, random_state=42) 
y_pred = ifr.fit_predict(X)
colors = np.array(['#377eb8', '#ff7f00'])
plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[(y_pred + 1) // 2])

y_pred  # 1 means normal value, -1 means anomalous value

sns.set(style="darkgrid")
g_3 = sns.jointplot("blocks", "sum_output_price", data=df_2,  height=14, color="k").plot_joint(sns.kdeplot, zorder=0, n_levels=40)

"""This graph clearly demonstrates anomalies, that is, moments when the cost was extremely high in relation to the "normal" cost.

Now we try out with some other outlier detection algorithms and check which gives us better results for outlier detection.

Hence, we use a library called **pyod** which hosts a number of outlier detection algorithms.
"""

pip install pyod

"""### KNN Classifier  (Proximity-Based)"""

from pyod.models.knn import KNN   # kNN detector

# train kNN detector
clf_name = 'KNN'
clf = KNN()
clf.fit(X)

y_pred = clf.predict(X)  # outlier labels (0 or 1)
y_scores = clf.decision_function(X)  # outlier scores

y_pred

"""0 means normal value while 1 means anomalous value."""

colors = np.array(['#377eb8', '#ff7f00'])
plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[(y_pred - 1) // 2])

"""Finding the ROC Accuracy score for the prediction label."""

clf.fit_predict_score(X[:, 0].reshape(-1,1), y_pred, scoring='roc_auc_score')

"""### Angle-based Outlier Detector (Probabilistic Based Model)"""

from pyod.models import abod

clf_abod = abod.ABOD(contamination=0.1, n_neighbors=5, method='fast')
clf_abod.fit(X)

y_pred = clf_abod.predict(X)  # outlier labels (0 or 1)
y_scores = clf_abod.decision_function(X)  # outlier scores

colors = np.array(['#377eb8', '#ff7f00'])
plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[(y_pred - 1) // 2])

clf_abod.fit_predict_score(X[:, 0].reshape(-1,1), y_pred, scoring='roc_auc_score')

"""### Linear Model PCA"""

from pyod.models.pca import PCA

clf_pca = PCA()
clf_pca.fit(X)

y_pred = clf_pca.predict(X)  # outlier labels (0 or 1)
y_scores = clf_pca.decision_function(X)  # outlier scores

y_pred

colors = np.array(['#377eb8', '#ff7f00'])
plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[(y_pred - 1) // 2])

clf_pca.fit_predict_score(X[:, 0].reshape(-1,1), y_pred, scoring='roc_auc_score')